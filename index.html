<!DOCTYPE html>
<html>
  <head>
    <title>PolyZone Creator (Single JSON Export)</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.css"
      integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"
      integrity="sha512-gc3xjCmIy673V6MyOAZhIW93xhM9ei1I+gLbmFjUHIjocENRsLX/QUE1htk5q1XV2D/iie/VQ8DXI6Vu8bexvQ=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />

    <style>
      html,
      body,
      #map1 {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        z-index: 1;
        background-color: #143c6a;
      }
      .btn {
        position: absolute;
        z-index: 10;
        border-radius: 3px;
        padding: 5px 15px;
        border-color: #202020;
        background-color: #303030;
        color: white;
      }
      .btn-clear {
        top: 2px;
        right: 2px;
      }
      .btn-debug {
        top: 2px;
        right: 140px;
      }
      .btn-overlay {
        top: 2px;
        right: 250px;
      }
      .btn-download {
        top: 2px;
        right: 370px;
      }
      .btn:hover {
        cursor: pointer;
      }
      .btn:active {
        background-color: #404040;
      }
      .leaflet-grid-label .lng {
        margin-left: 8px;
        -webkit-transform: rotate(90deg);
        transform: rotate(90deg);
      }
    </style>
  </head>
  <body>
    <div id="map1"></div>

    <button class="btn btn-clear" onclick="clearLayer();">
      Clear All Shapes
    </button>

    <button
      class="btn btn-debug"
      onclick="debug = !debug;this.style.backgroundColor = debug ? '#40aa40' : '#303030';"
    >
      Debug Grid
    </button>

    <button
      class="btn btn-overlay"
      onclick="overlay = !overlay;this.style.backgroundColor = overlay ? '#40aa40' : '#303030';setOverlay();"
    >
      Overlay Grid
    </button>

    <button class="btn btn-download" onclick="downloadJSON();">
      Download JSON
    </button>

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.js"
      integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"
      integrity="sha512-ozq8xQKq6urvuU6jNgkfqAmT7jKN2XumbrX1JiB3TnF7tI48DPI4Gy1GXKD/V3EExgAs1V+pRO7vwtS1LHg0Gw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <script>
      //Map Options
      var mapMinZoom = 0;
      var mapMaxZoom = 7;
      var mapMaxResolution = 0.25;
      var mapMinResolution = Math.pow(2, mapMaxZoom) * mapMaxResolution;
      var mapCenterLat = -5525;
      var mapCenterLng = 3755;
      var gtaOffset = 0.66;
      var debug = false;
      var overlay = false;
      var bottomLeft = [-8192, 0];
      var topRight = [0, 8192];
      var bounds = [bottomLeft, topRight];

      // ---------------------------
      // SINGLE EXPORT STATE
      // ---------------------------
      var currentName = null;      // filename base
      var currentPoints = null;    // [{X,Y}, ... closed]
      var currentLayer = null;     // Leaflet layer reference (only one polygon)

      function toFloat(n, digits = 2) {
        return parseFloat(Number(n).toFixed(digits));
      }

      //Create a new (square) coordinate system
      var crs = L.CRS.Simple;
      crs.scale = function (zoom) {
        return Math.pow(2, zoom) / mapMinResolution;
      };

      //Create GTA map tiles
      var layer = L.tileLayer("tiles/{z}/{x}/{y}.png", {
        minZoom: mapMinZoom,
        maxZoom: mapMaxZoom,
        attribution: "",
        noWrap: true,
        tms: true,
      });

      //Create the map object
      var map = new L.Map("map1", {
        maxZoom: mapMaxZoom,
        minZoom: mapMinZoom,
        layers: [layer],
        crs: crs,
        center: [mapCenterLat, mapCenterLng],
        zoom: 3,
      });

      //Shows GTA grid overlay on map
      let bgimage = L.imageOverlay("https://i.imgur.com/MQr04nZ.jpg", bounds, {
        opacity: 0,
      }).addTo(map);

      function setOverlay() {
        let imagelee = document.querySelector(".leaflet-image-layer");
        imagelee.style.opacity = overlay ? 0.5 : 0;
      }

      //Create Leaflet.Draw toolbar/layer
      L.Draw.Polyline.prototype._onTouch = L.Util.falseFn;

      var editableLayers = L.featureGroup();
      map.addLayer(editableLayers);

      var drawControl = new L.Control.Draw({
        draw: {
          polyline: false,
          circle: false,       // <- circles aus, weil du "eine area" + vector array willst
          rectangle: true,
          polygon: true,
          marker: false,
          circlemarker: false,
        },
        edit: {
          featureGroup: editableLayers,
        },
      });
      map.addControl(drawControl);

      //Convert latlng on the map to GTA coords
      function latlngToGTA(latlng) {
        var x = (latlng.lng - mapCenterLng) / gtaOffset;
        var y = (latlng.lat - mapCenterLat) / gtaOffset;
        return { X: toFloat(x, 2), Y: toFloat(y, 2) };
      }

      function closePolygon(points) {
        if (!points || points.length < 3) return points;
        const first = points[0];
        const last = points[points.length - 1];
        if (first.X !== last.X || first.Y !== last.Y) {
          points.push({ X: first.X, Y: first.Y });
        }
        return points;
      }

      function layerToPoints(layer) {
        const ring = layer._latlngs?.[0] ?? [];
        const points = ring.map((latlng) => latlngToGTA(latlng));
        return closePolygon(points);
      }

      function escapeHtml(str) {
        return str
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      function bindPopup(layer) {
        const json = JSON.stringify(currentPoints ?? [], null, 2);
        layer.bindPopup(
          "<b>" +
            escapeHtml((currentName ?? "unnamed") + ".json") +
            "</b><br/><code style='white-space:pre-wrap;'>" +
            escapeHtml(json) +
            "</code>",
          { minWidth: 500 }
        );
      }

      function clearLayer() {
        editableLayers.getLayers().forEach((l) => editableLayers.removeLayer(l));
        currentLayer = null;
        currentName = null;
        currentPoints = null;
      }

      function sanitizeFilename(name) {
        // keep it simple & safe
        return (name || "area")
          .trim()
          .replaceAll(/[^a-zA-Z0-9_\- ]/g, "")
          .replaceAll(/\s+/g, "_")
          .slice(0, 60);
      }

      function downloadJSON() {
        if (!currentPoints || currentPoints.length < 4) {
          alert("Kein Polygon vorhanden zum Export.");
          return;
        }
        const filename = (currentName ? currentName : "area") + ".json";
        const blob = new Blob([JSON.stringify(currentPoints, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

      // If user deletes the polygon
      map.on(L.Draw.Event.DELETED, (e) => {
        // since we only allow one, any delete clears state
        clearLayer();
      });

      // On shape created
      map.on(L.Draw.Event.CREATED, (e) => {
        const type = e.layerType;
        const layer = e.layer;

        // Only allow polygon/rectangle as "area"
        if (type !== "polygon" && type !== "rectangle") return;

        // Replace existing area automatically
        if (currentLayer) {
          editableLayers.removeLayer(currentLayer);
        }

        // Ask for filename base
        const rawName = prompt("Enter area name (will be filename):", currentName ?? "area");
        currentName = sanitizeFilename(rawName);

        currentLayer = layer;
        currentPoints = layerToPoints(layer);

        bindPopup(layer);
        editableLayers.addLayer(layer);
      });

      // On shape edited
      map.on(L.Draw.Event.EDITED, (e) => {
        e.layers.eachLayer(function (layer) {
          // Only track the single current layer
          if (!currentLayer || layer !== currentLayer) return;

          currentPoints = layerToPoints(layer);
          bindPopup(layer);
        });
      });
    </script>
  </body>
</html>
