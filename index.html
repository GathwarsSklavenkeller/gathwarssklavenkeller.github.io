<!DOCTYPE html>
<html>
  <head>
    <title>PS Challenges Border Creator</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.css"
      integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"
      integrity="sha512-gc3xjCmIy673V6MyOAZhIW93xhM9ei1I+gLbmFjUHIjocENRsLX/QUE1htk5q1XV2D/iie/VQ8DXI6Vu8bexvQ=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />

    <style>
      html,
      body,
      #map1 {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        z-index: 1;
        background-color: #143c6a;
      }
      .btn {
        position: absolute;
        z-index: 10;
        border-radius: 3px;
        padding: 5px 15px;
        border-color: #202020;
        background-color: #303030;
        color: white;
      }
      .btn-clear {
        top: 2px;
        right: 2px;
      }
      .btn-debug {
        top: 2px;
        right: 140px;
      }
      .btn-overlay {
        top: 2px;
        right: 250px;
      }
      .btn-download {
        top: 2px;
        right: 370px;
      }
      .btn:hover {
        cursor: pointer;
      }
      .btn:active {
        background-color: #404040;
      }
      .leaflet-grid-label .lng {
        margin-left: 8px;
        -webkit-transform: rotate(90deg);
        transform: rotate(90deg);
      }
    </style>
  </head>
  <body>
    <div id="map1"></div>

    <button class="btn btn-clear" onclick="clearLayer();">
      Clear All Shapes
    </button>

    <button
      class="btn btn-debug"
      onclick="debug = !debug;this.style.backgroundColor = debug ? '#40aa40' : '#303030';"
    >
      Debug Grid
    </button>

    <button
      class="btn btn-overlay"
      onclick="overlay = !overlay;this.style.backgroundColor = overlay ? '#40aa40' : '#303030';setOverlay();"
    >
      Overlay Grid
    </button>

    <button class="btn btn-download" onclick="downloadJSON();">
      Download JSON
    </button>

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.js"
      integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"
      integrity="sha512-ozq8xQKq6urvuU6jNgkfqAmT7jKN2XumbrX1JiB3TnF7tI48DPI4Gy1GXKD/V3EExgAs1V+pRO7vwtS1LHg0Gw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <script>
      //Map Options
      var mapMinZoom = 0;
      var mapMaxZoom = 7;
      var mapMaxResolution = 0.25;
      var mapMinResolution = Math.pow(2, mapMaxZoom) * mapMaxResolution;
      var mapCenterLat = -5525;
      var mapCenterLng = 3755;
      var gtaOffset = 0.66;
      var debug = false;
      var overlay = false;
      var bottomLeft = [-8192, 0];
      var topRight = [0, 8192];
      var bounds = [bottomLeft, topRight];

      // ---------------------------
      // JSON EXPORT STATE
      // ---------------------------
      // Export format:
      // [
      //   { "name": "zone1", "type": "polygon", "points": [ {X:...,Y:...}, ...closed ] },
      //   { "name": "circle1", "type": "circle", "center": {X:...,Y:...}, "radius": 123.45 }
      // ]
      var exportData = [];

      function toFloat(n, digits = 2) {
        // Ensure actual number (float) in JSON, not string
        return parseFloat(Number(n).toFixed(digits));
      }

      //Create a new (square) coordinate system
      var crs = L.CRS.Simple;
      crs.scale = function (zoom) {
        return Math.pow(2, zoom) / mapMinResolution;
      };

      //Create GTA map tiles
      var layer = L.tileLayer("tiles/{z}/{x}/{y}.png", {
        minZoom: mapMinZoom,
        maxZoom: mapMaxZoom,
        attribution: "",
        noWrap: true,
        tms: true,
      });

      //Create the map object
      var map = new L.Map("map1", {
        maxZoom: mapMaxZoom,
        minZoom: mapMinZoom,
        layers: [layer],
        crs: crs,
        center: [mapCenterLat, mapCenterLng],
        zoom: 3,
      });

      //Shows GTA grid overlay on map
      let bgimage = L.imageOverlay("https://i.imgur.com/MQr04nZ.jpg", bounds, {
        opacity: 0,
      }).addTo(map);

      function setOverlay() {
        let imagelee = document.querySelector(".leaflet-image-layer");
        imagelee.style.opacity = overlay ? 0.5 : 0;
      }

      //Create Leaflet.Draw toolbar/layer
      //Fix for broken Draw
      L.Draw.Polyline.prototype._onTouch = L.Util.falseFn;

      var editableLayers = L.featureGroup();
      map.addLayer(editableLayers);

      var drawControl = new L.Control.Draw({
        draw: {
          polyline: false,
          circlemarker: false,
        },
        edit: {
          featureGroup: editableLayers,
        },
      });
      map.addControl(drawControl);

      //Convert latlng on the map to GTA coords
      function latlngToGTA(latlng) {
        var x = (latlng.lng - mapCenterLng) / gtaOffset;
        var y = (latlng.lat - mapCenterLat) / gtaOffset;
        // return numeric floats
        return { X: toFloat(x, 2), Y: toFloat(y, 2) };
      }

      //Remove all shapes from Draw
      function clearLayer() {
        editableLayers.getLayers().forEach((layer) => {
          editableLayers.removeLayer(layer);
        });
        exportData = [];
      }

      // Ensure polygon is closed: last point equals first point
      function closePolygon(points) {
        if (!points || points.length < 3) return points;
        const first = points[0];
        const last = points[points.length - 1];
        if (first.X !== last.X || first.Y !== last.Y) {
          points.push({ X: first.X, Y: first.Y });
        }
        return points;
      }

      function polygonToPoints(layer) {
        // Leaflet polygon: layer._latlngs[0] is ring
        const ring = layer._latlngs?.[0] ?? [];
        const points = ring.map((latlng) => latlngToGTA(latlng));
        return closePolygon(points);
      }

      function circleToData(layer) {
        return {
          center: latlngToGTA(layer.getLatLng()),
          // keeping your old scaling *1.5, keep or remove as you like:
          radius: toFloat(layer.getRadius() * 1.5, 2),
        };
      }

      function upsertExportItem(id, item) {
        const idx = exportData.findIndex((z) => z.id === id);
        if (idx === -1) exportData.push(item);
        else exportData[idx] = item;
      }

      function removeExportItem(id) {
        exportData = exportData.filter((z) => z.id !== id);
      }

      function layerToPopupJSON(item) {
        return (
          "<code style='white-space:pre-wrap;'>" +
          escapeHtml(JSON.stringify(item, null, 2)) +
          "</code>"
        );
      }

      function escapeHtml(str) {
        return str
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      function downloadJSON() {
        // Strip internal ids from export (optional)
        const clean = exportData.map(({ id, ...rest }) => rest);
        const blob = new Blob([JSON.stringify(clean, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "polyzones.json";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

      // Track deletes
      map.on(L.Draw.Event.DELETED, (e) => {
        e.layers.eachLayer(function (layer) {
          if (layer && layer.__exportId) {
            removeExportItem(layer.__exportId);
          }
        });
      });

      //On shape created
      map.on(L.Draw.Event.CREATED, (e) => {
        var type = e.layerType,
          layer = e.layer;

        // Unique id for this layer in export
        layer.__exportId = crypto?.randomUUID ? crypto.randomUUID() : String(Date.now() + Math.random());

        if (type === "marker") {
          const position = latlngToGTA(layer.getLatLng());
          layer.bindPopup(
            "GTA Position: " +
              JSON.stringify(position) +
              ", latlng: " +
              layer.getLatLng()
          );
        } else if (type === "circle") {
          const name = prompt("Enter circlezone name: ") || "unnamed_circle";
          const c = circleToData(layer);

          const item = {
            id: layer.__exportId,
            name,
            type: "circle",
            center: c.center,
            radius: c.radius,
          };

          upsertExportItem(layer.__exportId, item);
          layer.bindPopup(layerToPopupJSON(item), { minWidth: 500 });
        } else {
          const name = prompt("Enter polyzone name:") || "unnamed_polygon";
          const points = polygonToPoints(layer);

          const item = {
            id: layer.__exportId,
            name,
            type: "polygon",
            points, // [{X,Y}, ... closed]
          };

          upsertExportItem(layer.__exportId, item);
          console.log(item);
          layer.bindPopup(layerToPopupJSON(item), { minWidth: 500 });
        }

        editableLayers.addLayer(layer);
      });

      //On shape edited
      map.on(L.Draw.Event.EDITED, (e) => {
        var layers = e.layers;

        layers.eachLayer(function (layer) {
          if (!layer.__exportId) return;

          const existing = exportData.find((z) => z.id === layer.__exportId);
          if (!existing) return;

          if (layer instanceof L.Marker) {
            const position = latlngToGTA(layer.getLatLng());
            layer.bindPopup(
              "GTA Position: " +
                JSON.stringify(position) +
                ", latlng: " +
                layer.getLatLng()
            );
          } else if (layer instanceof L.Circle) {
            const c = circleToData(layer);
            const item = {
              ...existing,
              center: c.center,
              radius: c.radius,
            };
            upsertExportItem(layer.__exportId, item);
            layer.bindPopup(layerToPopupJSON(item), { minWidth: 500 });
          } else {
            const points = polygonToPoints(layer);
            const item = {
              ...existing,
              points,
            };
            upsertExportItem(layer.__exportId, item);
            layer.bindPopup(layerToPopupJSON(item), { minWidth: 500 });
          }
        });
      });
    </script>
  </body>
</html>
